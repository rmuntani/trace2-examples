# Rubocop

rubocop is a popular runner that is used to lint Ruby code. To
have a real-world example of it's usage, it will be run with an
old version of trace2.

## How to run it

First, you should have cloned the trace2 repository to your machine.
After that, go to it's directory and:

```bash
git checkout a159988
```

After that:

```bash
rubocop
```

To run it with trace2:

```bash
trace2 -o full_rubocop_run --manual rubocop -C false
```

As the graph generated by doing that has more than 7000 edges, dot takes
a long time to create the .pdf that shows everything that happend during
runtime. The `full_rubocop_run` file is the .dot representation of the full
run.

Running rubocop on a single file is performed to generate a smaller file.
To do that:

```bash
trace2 -o partial_rubocop_run --manual rubocop lib/trace2/options.rb -C false
```
The partial run still generates a graph that has too many edges, that is,
around 5000 edges. The `partial_rubocop_run` file is the .dot representation
of it's runtime.

To check only the classes that interact with the Runner class,
the runner_filter.yml was created.

To use it:

```bash
trace2 -o full_rubocop_run --filter ../trace2-examples/rubocop/runner_filter.yml rubocop -C false
```

That stil generates a graph that could not be properly rendered by graphviz, as a
single node has almost 500 edges leaving it. Despite that, the excercise was useful to
determine `Rubocop::Runner` that is responsible for calling all the `Cops`. Similar logic could
be applied to other runners to find out how responsibilities are distributed.
